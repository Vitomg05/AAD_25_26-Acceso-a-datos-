import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.Scanner;

public class MiniFileExplorer {
    private static final Scanner SC = new Scanner(System.in);
    private static final DateTimeFormatter TS_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withLocale(Locale.getDefault());

    public static void main(String[] args) {
        System.out.println("=== Mini Explorador de Ficheros (Java) ===");
        Path dir = solicitarDirectorio();
        if (dir == null) return; // por si el usuario sale

        while (true) {
            System.out.println();
            listarDirectorio(dir);
            System.out.println();
            System.out.println("Directorio actual: " + dir.toAbsolutePath());
            System.out.println("------------------------------");
            System.out.println("1) Crear fichero vacío");
            System.out.println("2) Mover fichero");
            System.out.println("3) Borrar fichero");
            System.out.println("4) Cambiar de directorio");
            System.out.println("0) Salir");
            System.out.print("Elige una opción: ");

            int opcion = leerEnteroSeguro();
            System.out.println();
            switch (opcion) {
                case 1 -> crearFicheroVacio(dir);
                case 2 -> moverFichero(dir);
                case 3 -> borrarFichero(dir);
                case 4 -> {
                    Path nuevo = solicitarDirectorio();
                    if (nuevo != null) dir = nuevo;
                }
                case 0 -> {
                    System.out.println("¡Hasta luego!");
                    return;
                }
                default -> System.out.println("Opción no válida.");
            }
        }
    }

    private static Path solicitarDirectorio() {
        while (true) {
            System.out.print("Introduce una ruta de directorio (o ENTER para salir): ");
            String input = SC.nextLine().trim();
            if (input.isEmpty()) {
                System.out.println("Saliendo.");
                return null;
            }
            try {
                Path dir = Paths.get(input).toAbsolutePath().normalize();
                if (!Files.exists(dir)) {
                    System.out.println("Error: el directorio no existe: " + dir);
                    continue;
                }
                if (!Files.isDirectory(dir)) {
                    System.out.println("Error: la ruta no es un directorio: " + dir);
                    continue;
                }
                if (!Files.isReadable(dir)) {
                    System.out.println("Error: no hay permisos de lectura sobre: " + dir);
                    continue;
                }
                return dir;
            } catch (InvalidPathException ipe) {
                System.out.println("Ruta inválida: " + ipe.getMessage());
            }
        }
    }

    private static void listarDirectorio(Path dir) {
        System.out.println("\nContenido de: " + dir.toAbsolutePath());
        System.out.printf("%-1s %-40s %12s %22s%n", "T", "Nombre", "Tamaño(B)", "Últ. modificación");
        System.out.println("-".repeat(80));
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
            for (Path p : stream) {
                try {
                    BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);
                    String tipo = attrs.isDirectory() ? "D" : (attrs.isRegularFile() ? "F" : "?");
                    String nombre = p.getFileName().toString();
                    String tam = attrs.isRegularFile() ? String.valueOf(attrs.size()) : "-";
                    LocalDateTime ldt = LocalDateTime.ofInstant(Instant.ofEpochMilli(attrs.lastModifiedTime().toMillis()), ZoneId.systemDefault());
                    String fecha = TS_FORMAT.format(ldt);
                    System.out.printf("%-1s %-40s %12s %22s%n", tipo, nombre, tam, fecha);
                } catch (IOException e) {
                    System.out.printf("%-1s %-40s %12s %22s%n", "?", p.getFileName(), "(error)", "(desconocido)");
                }
            }
        } catch (AccessDeniedException ade) {
            System.out.println("Permiso denegado: " + ade.getFile());
        } catch (IOException e) {
            System.out.println("Error al listar el directorio: " + e.getMessage());
        }
    }

    private static void crearFicheroVacio(Path dirBase) {
        System.out.print("Nombre (o ruta) del nuevo fichero: ");
        String nombre = SC.nextLine().trim();
        if (nombre.isEmpty()) {
            System.out.println("Operación cancelada.");
            return;
        }
        Path destino = resolverRutaRespectoA(dirBase, nombre);
        try {
            if (Files.exists(destino)) {
                System.out.println("Error: ya existe un fichero o directorio con ese nombre: " + destino);
                return;
            }
            Files.createDirectories(destino.getParent()); // por si se indicó subcarpeta
            Files.createFile(destino);
            System.out.println("Fichero creado: " + destino);
        } catch (AccessDeniedException ade) {
            System.out.println("Permiso denegado al crear: " + destino);
        } catch (NoSuchFileException nsfe) {
            System.out.println("Directorio inexistente para la ruta: " + destino);
        } catch (IOException e) {
            System.out.println("Error al crear el fichero: " + e.getMessage());
        }
    }

    private static void moverFichero(Path dirBase) {
        System.out.print("Ruta del fichero de origen: ");
        String origenStr = SC.nextLine().trim();
        if (origenStr.isEmpty()) { System.out.println("Operación cancelada."); return; }
        Path origen = resolverRutaRespectoA(dirBase, origenStr);

        System.out.print("Ruta de destino (directorio o ruta de fichero): ");
        String destinoStr = SC.nextLine().trim();
        if (destinoStr.isEmpty()) { System.out.println("Operación cancelada."); return; }
        Path destinoEntrada = resolverRutaRespectoA(dirBase, destinoStr);

        try {
            if (!Files.exists(origen) || !Files.isRegularFile(origen)) {
                System.out.println("Error: el origen no existe o no es un fichero: " + origen);
                return;
            }
            Path destino;
            if (Files.exists(destinoEntrada) && Files.isDirectory(destinoEntrada)) {
                destino = destinoEntrada.resolve(origen.getFileName());
            } else {
                Path parent = destinoEntrada.getParent();
                if (parent != null && !Files.exists(parent)) {
                    System.out.println("Error: el directorio de destino no existe: " + parent);
                    return;
                }
                destino = destinoEntrada;
            }
            if (Files.exists(destino)) {
                System.out.println("Error: ya existe un fichero con el nombre de destino: " + destino);
                return;
            }
            Files.move(origen, destino, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Fichero movido a: " + destino);
        } catch (AtomicMoveNotSupportedException amnse) {
            // Reintento sin ATOMIC_MOVE si no está soportado
            try {
                Files.move(origen, resolverDestinoFinal(destinoEntrada, origen), StandardCopyOption.REPLACE_EXISTING);
                System.out.println("Fichero movido.");
            } catch (IOException e2) {
                System.out.println("Error al mover (reintento): " + e2.getMessage());
            }
        } catch (AccessDeniedException ade) {
            System.out.println("Permiso denegado al mover: " + ade.getFile());
        } catch (IOException e) {
            System.out.println("Error al mover el fichero: " + e.getMessage());
        }
    }

    private static Path resolverDestinoFinal(Path destinoEntrada, Path origen) throws IOException {
        if (Files.exists(destinoEntrada) && Files.isDirectory(destinoEntrada)) {
            return destinoEntrada.resolve(origen.getFileName());
        }
        return destinoEntrada;
    }

    private static void borrarFichero(Path dirBase) {
        System.out.print("Ruta del fichero a borrar: ");
        String ruta = SC.nextLine().trim();
        if (ruta.isEmpty()) { System.out.println("Operación cancelada."); return; }
        Path objetivo = resolverRutaRespectoA(dirBase, ruta);
        try {
            if (!Files.exists(objetivo)) {
                System.out.println("No existe: " + objetivo);
                return;
            }
            if (!Files.isRegularFile(objetivo)) {
                System.out.println("La ruta no es un fichero regular: " + objetivo);
                return;
            }
            System.out.print("¿Seguro que deseas borrar '" + objetivo + "'? (s/N): ");
            String conf = SC.nextLine().trim().toLowerCase(Locale.ROOT);
            if (!conf.equals("s") && !conf.equals("si") && !conf.equals("sí")) {
                System.out.println("Borrado cancelado.");
                return;
            }
            Files.delete(objetivo);
            System.out.println("Fichero borrado.");
        } catch (AccessDeniedException ade) {
            System.out.println("Permiso denegado al borrar: " + ade.getFile());
        } catch (DirectoryNotEmptyException dnee) {
            System.out.println("No es un fichero vacío o la ruta apunta a un directorio no vacío.");
        } catch (IOException e) {
            System.out.println("Error al borrar el fichero: " + e.getMessage());
        }
    }

    private static int leerEnteroSeguro() {
        try {
            String line = SC.nextLine();
            return Integer.parseInt(line.trim());
        } catch (NumberFormatException ex) {
            return -1; // fuerza opción no válida
        }
    }

    private static Path resolverRutaRespectoA(Path base, String entrada) {
        try {
            Path p = Paths.get(entrada);
            if (!p.isAbsolute()) {
                p = base.resolve(p).normalize();
            }
            return p;
        } catch (InvalidPathException ipe) {
            System.out.println("Ruta inválida: " + ipe.getMessage());
            // devuelve algo seguro para evitar NPE aguas abajo
            return base.resolve("__ruta_invalida__");
        }
    }
}
